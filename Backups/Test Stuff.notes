// MARK: - Optimized Canvas View with Zoom/Pan
struct CanvasView: View {
    @EnvironmentObject var graph: GraphState
    @State private var zoomScale: CGFloat = 1.0
    @State private var canvasOffset: CGSize = .zero
    @State private var previousCanvasOffset: CGSize = .zero
    @State private var isDraggingCanvas = false
    
    // Cached transformed positions for performance
    @State private var transformedPortFrames: [PortKey: CGRect] = [:]
    @State private var updateTimer: Timer?
    
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Background with pan gesture
                Color.clear
                    .contentShape(Rectangle())
                    .gesture(canvasPanGesture)
                    .onTapGesture { location in
                        let canvasLocation = screenToCanvas(location)
                        graph.lastMousePosition = canvasLocation
                        graph.selectNode(nil)
                    }
                    .gesture(
                        MagnificationGesture()
                            .onChanged { value in
                                let newScale = (zoomScale * value).clamped(to: 0.25...3.0)
                                zoomScale = newScale
                            }
                    )
                
                // Main canvas content with transformations
                ZStack {
                    GridBackground()
                        .ignoresSafeArea()
                        .allowsHitTesting(false)
                    
                    // Optimized wire rendering
                    Canvas { context, size in
                        context.scaleBy(x: zoomScale, y: zoomScale)
                        context.translateBy(x: canvasOffset.width, y: canvasOffset.height)
                        
                        for edge in graph.edges {
                            drawWire(edge: edge, in: context)
                        }
                    }
                    .allowsHitTesting(false)
                    
                    // Drag preview wire
                    if let dragContext = graph.dragging {
                        WireTempPath(
                            from: canvasToScreen(dragContext.startPoint),
                            to: dragContext.currentPoint
                        )
                    }
                    
                    // Nodes with optimized positioning
                    ForEach(Array(graph.nodes.values), id: \.id) { node in
                        OptimizedNodeCard(
                            node: node,
                            scale: zoomScale,
                            onDragChanged: { translation in
                                handleNodeDrag(node: node, translation: translation)
                            },
                            onDragEnded: { translation in
                                finalizeNodeDrag(node: node, translation: translation)
                            }
                        )
                        .scaleEffect(zoomScale)
                        .position(canvasToScreen(CGPoint(x: node.x, y: node.y)))
                    }
                }
            }
            .coordinateSpace(name: "canvas")
            .onAppear {
                startPortFrameUpdates()
            }
            .onDisappear {
                updateTimer?.invalidate()
            }
        }
    }
    
    // MARK: - Coordinate Transformations
    
    private func screenToCanvas(_ point: CGPoint) -> CGPoint {
        CGPoint(
            x: (point.x - canvasOffset.width) / zoomScale,
            y: (point.y - canvasOffset.height) / zoomScale
        )
    }
    
    private func canvasToScreen(_ point: CGPoint) -> CGPoint {
        CGPoint(
            x: point.x * zoomScale + canvasOffset.width,
            y: point.y * zoomScale + canvasOffset.height
        )
    }
    
    // MARK: - Gesture Handlers
    
    private var canvasPanGesture: some Gesture {
        DragGesture(minimumDistance: 10)
            .onChanged { value in
                if !isDraggingCanvas {
                    isDraggingCanvas = true
                    previousCanvasOffset = canvasOffset
                }
                canvasOffset = CGSize(
                    width: previousCanvasOffset.width + value.translation.width,
                    height: previousCanvasOffset.height + value.translation.height
                )
            }
            .onEnded { _ in
                isDraggingCanvas = false
                previousCanvasOffset = canvasOffset
            }
    }
    
    private func handleNodeDrag(node: Node, translation: CGSize) {
        // Visual feedback only - don't update state yet
    }
    
    private func finalizeNodeDrag(node: Node, translation: CGSize) {
        guard var updatedNode = graph.nodes[node.id] else { return }
        
        // Convert translation to canvas coordinates
        let canvasTranslation = CGSize(
            width: translation.width / zoomScale,
            height: translation.height / zoomScale
        )
        
        updatedNode.x = node.x + canvasTranslation.width
        updatedNode.y = node.y + canvasTranslation.height
        
        // Batch update
        graph.nodes[node.id] = updatedNode
        
        // Debounced flow computation
        scheduleFlowComputation()
    }
    
    // MARK: - Performance Optimizations
    
    private func startPortFrameUpdates() {
        // Update port frames at a lower frequency
        updateTimer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { _ in
            updateTransformedPortFrames()
        }
    }
    
    private func updateTransformedPortFrames() {
        var newFrames: [PortKey: CGRect] = [:]
        for (key, frame) in graph.portFrames {
            let transformedOrigin = canvasToScreen(CGPoint(x: frame.minX, y: frame.minY))
            newFrames[key] = CGRect(
                origin: transformedOrigin,
                size: CGSize(
                    width: frame.width * zoomScale,
                    height: frame.height * zoomScale
                )
            )
        }
        transformedPortFrames = newFrames
    }
    
    private func scheduleFlowComputation() {
        // Cancel previous computation
        NSObject.cancelPreviousPerformRequests(withTarget: graph, selector: #selector(graph.computeFlows), object: nil)
        
        // Schedule new computation with delay
        graph.perform(#selector(graph.computeFlows), with: nil, afterDelay: 0.3)
    }
    
    private func drawWire(edge: Edge, in context: GraphicsContext) {
        guard let fromNode = graph.nodes[edge.fromNode],
              let toNode = graph.nodes[edge.toNode],
              let fromRecipe = RECIPES.first(where: { $0.id == fromNode.recipeID }),
              let toRecipe = RECIPES.first(where: { $0.id == toNode.recipeID }) else {
            return
        }
        
        // Approximate port positions without GeometryReader
        let fromPoint = approximatePortPosition(
            node: fromNode,
            recipe: fromRecipe,
            item: edge.item,
            side: .output
        )
        let toPoint = approximatePortPosition(
            node: toNode,
            recipe: toRecipe,
            item: edge.item,
            side: .input
        )
        
        let path = createCubicPath(from: fromPoint, to: toPoint)
        context.stroke(path, with: .color(.orange.opacity(0.9)), lineWidth: Constants.wireLineWidth / zoomScale)
    }
    
    private func approximatePortPosition(node: Node, recipe: Recipe, item: String, side: IOSide) -> CGPoint {
        // Calculate approximate position without GeometryReader
        let baseX = node.x
        let baseY = node.y
        
        // Estimate based on node layout
        let xOffset: CGFloat = side == .output ? 80 : -80
        return CGPoint(x: baseX + xOffset, y: baseY)
    }
}

// MARK: - Optimized Node Card
struct OptimizedNodeCard: View {
    var node: Node
    var scale: CGFloat
    var onDragChanged: (CGSize) -> Void
    var onDragEnded: (CGSize) -> Void
    
    @State private var dragOffset: CGSize = .zero
    @State private var isDragging = false
    @EnvironmentObject var graph: GraphState
    
    var body: some View {
        NodeCardContent(node: node)
            .offset(dragOffset)
            .scaleEffect(isDragging ? 1.02 : 1.0)
            .gesture(
                DragGesture()
                    .onChanged { value in
                        if !isDragging {
                            isDragging = true
                            graph.selectNode(node.id)
                        }
                        dragOffset = value.translation
                        onDragChanged(value.translation)
                    }
                    .onEnded { value in
                        isDragging = false
                        onDragEnded(value.translation)
                        
                        // Reset with animation
                        withAnimation(.easeOut(duration: 0.2)) {
                            dragOffset = .zero
                        }
                    }
            )
    }
}

// Helper extension
extension Comparable {
    func clamped(to limits: ClosedRange<Self>) -> Self {
        return min(max(self, limits.lowerBound), limits.upperBound)
    }
}
